(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{579:function(t,a,v){"use strict";v.r(a);var r=v(5),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),v("h3",{attrs:{id:"调用栈中的数据是如何回收的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调用栈中的数据是如何回收的"}},[t._v("#")]),t._v(" 调用栈中的数据是如何回收的")]),t._v(" "),v("p",[t._v("当一个函数调用结束的时候，js引擎会通过下移ESP（记录当前执行状态的指针）来销毁改函数保存在调用栈中的执行上下文")]),t._v(" "),v("h3",{attrs:{id:"堆中的数据是如何回收的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆中的数据是如何回收的"}},[t._v("#")]),t._v(" 堆中的数据是如何回收的")]),t._v(" "),v("p",[t._v("收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器")]),t._v(" "),v("p",[t._v("根据生命周期把堆分成新生代和旧生代两个区域")]),t._v(" "),v("ol",[v("li",[t._v("新生代：生存时间短 比较小")]),t._v(" "),v("li",[t._v("老生代： 生存时间长 文件大\n对于这两种不同的区域使用主垃圾回收器（老） 副垃圾回收器（新）")])]),t._v(" "),v("h3",{attrs:{id:"垃圾回收器的工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[t._v("#")]),t._v(" 垃圾回收器的工作流程")]),t._v(" "),v("ol",[v("li",[t._v("引数清理")]),t._v(" "),v("li",[t._v("标记清理 遍历所有的对象添加标记，然后对活跃的对象清楚标记 然后回收非活跃对象所占据的内存，最后整理内存")])]),t._v(" "),v("p",[t._v("一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器")]),t._v(" "),v("h3",{attrs:{id:"副垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器")]),t._v(" "),v("p",[t._v("副垃圾回收主要负责回收新生区的对象，使用用Scavenge 算法来处理，将新生区分为对象区域和空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小\n因此，整个对象区域很容易被装满，所以出现了晋升策略，经过两次垃圾回收都还存在的对象 就会晋升到老代区域")]),t._v(" "),v("h3",{attrs:{id:"主垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收"}},[t._v("#")]),t._v(" 主垃圾回收")]),t._v(" "),v("p",[t._v("主垃圾回收主要负责旧生代区域，除了一些从新生代晋升的对象还有一些比较大的对象会直接分配到旧生代\n因为旧生代的对象大，如果也采用Scavenge算法，那么耗时大因此在旧生代采用了标记清理")]),t._v(" "),v("p",[t._v("除此之外还要了解全停顿，因为在进行垃圾回收的时候js脚本是暂停下来的，试想如果垃圾太多那么我js等待时间就比较长，在新生代还好但是老生代的数据都比较大，所以为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法")]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ol",[v("li",[t._v("要知道什么是垃圾回收")]),t._v(" "),v("li",[t._v("栈和堆里的是怎么回收的")]),t._v(" "),v("li",[t._v("新旧生代区别")]),t._v(" "),v("li",[t._v("全暂停 处理的方法")])]),t._v(" "),v("h2",{attrs:{id:"宏观的浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#宏观的浏览器"}},[t._v("#")]),t._v(" 宏观的浏览器")]),t._v(" "),v("h3",{attrs:{id:"打开浏览器有哪些进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#打开浏览器有哪些进程"}},[t._v("#")]),t._v(" 打开浏览器有哪些进程")]),t._v(" "),v("p",[t._v("敬请期待")]),t._v(" "),v("h3",{attrs:{id:"如何保证文件完整的传送到浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何保证文件完整的传送到浏览器"}},[t._v("#")]),t._v(" 如何保证文件完整的传送到浏览器")]),t._v(" "),v("p",[t._v("敬请期待")]),t._v(" "),v("h3",{attrs:{id:"为什么第二次打开网站变快了"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么第二次打开网站变快了"}},[t._v("#")]),t._v(" 为什么第二次打开网站变快了")]),t._v(" "),v("p",[t._v("敬请期待")]),t._v(" "),v("h3",{attrs:{id:"浏览器的缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的缓存"}},[t._v("#")]),t._v(" 浏览器的缓存")]),t._v(" "),v("p",[t._v("缓存的概念是在浏览器1.0中加入的"),v("br"),t._v("\n强缓存：Expires，Cache-Control"),v("br"),t._v("\n用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。"),v("br"),t._v("\n协商缓存：Etag和If-None-Match、Last-Modified和If-Modified-Since"),v("br"),t._v("\n用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。"),v("br"),t._v("\n两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。"),v("br"),t._v("\n两者区别：从名字就可以看出，强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互")]),t._v(" "),v("h3",{attrs:{id:"导航流程是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#导航流程是什么"}},[t._v("#")]),t._v(" 导航流程是什么？")]),t._v(" "),v("p",[t._v("敬请期待")]),t._v(" "),v("h3",{attrs:{id:"html是如何变成页面的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html是如何变成页面的"}},[t._v("#")]),t._v(" html是如何变成页面的")]),t._v(" "),v("p",[t._v("敬请期待")]),t._v(" "),v("h3",{attrs:{id:"开启gzip-需要与什么配合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开启gzip-需要与什么配合"}},[t._v("#")]),t._v(" 开启gzip 需要与什么配合")]),t._v(" "),v("p",[t._v("需要客户端和服务端同时支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了"),v("br"),t._v("\n客户端是否支持gzip呢，请求头中有个Accept-Encoding来标识对压缩的支持。客户端http请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到服务端的时候，服务器解析请求头，如果客户端支持gzip压缩，响应时对请求的资源进行压缩并返回给客户端，浏览器按照自己的方式解析，在http响应头，我们可以看到content-encoding:gzip，这是指服务端使用了gzip的压缩方式")])])}),[],!1,null,null,null);a.default=_.exports}}]);