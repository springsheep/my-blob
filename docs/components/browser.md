---
title: 浏览器 相关
date: 2021-12-30
tags:
  - 浏览器
categories:
  - 浏览器
sidebar: true
---

## 垃圾回收

### 调用栈中的数据是如何回收的

当一个函数调用结束的时候，js 引擎会通过下移 ESP（记录当前执行状态的指针）来销毁改函数保存在调用栈中的执行上下文

### 堆中的数据是如何回收的

收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器

根据生命周期把堆分成新生代和旧生代两个区域

1. 新生代：生存时间短 比较小
2. 老生代： 生存时间长 文件大
   对于这两种不同的区域使用主垃圾回收器（老） 副垃圾回收器（新）

### 垃圾回收器的工作流程

1. 引数清理
2. 标记清理 遍历所有的对象添加标记，然后对活跃的对象清楚标记 然后回收非活跃对象所占据的内存，最后整理内存

一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器

### 副垃圾回收器

副垃圾回收主要负责回收新生区的对象，使用用 Scavenge 算法来处理，将新生区分为对象区域和空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小
因此，整个对象区域很容易被装满，所以出现了晋升策略，经过两次垃圾回收都还存在的对象 就会晋升到老代区域

### 主垃圾回收

主垃圾回收主要负责旧生代区域，除了一些从新生代晋升的对象还有一些比较大的对象会直接分配到旧生代
因为旧生代的对象大，如果也采用 Scavenge 算法，那么耗时大因此在旧生代采用了标记清理

除此之外还要了解全停顿，因为在进行垃圾回收的时候 js 脚本是暂停下来的，试想如果垃圾太多那么我 js 等待时间就比较长，在新生代还好但是老生代的数据都比较大，所以为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法

## 总结

1. 要知道什么是垃圾回收
2. 栈和堆里的是怎么回收的
3. 新旧生代区别
4. 全暂停 处理的方法

## 宏观的浏览器

### 打开浏览器有哪些进程

浏览器进程 管理子进程和页面 存储功能 用户交互
渲染进程 js htm css 变成可交互页面 每个 tab 都有一个渲染进程 可以获取系统权限 放在沙箱里
gpu 进程 处理 css3 动画 ui 界面也适用于
插件进程 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响
网络进程 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程

### 如何保证文件完整的传送到浏览器

了解 ip udp 和 tcp 传输的区别  
IP 负责把数据包送达目的主机。  
UDP 负责把数据包送达具体应用。  
而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接  
tcp 相对于 udp 是有链接的 基于字节流的 有序的 多了重传和排序

### 为什么第二次打开网站变快了

浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。

dns 缓存 资源缓存 强缓存 弱缓存

### 浏览器的缓存

缓存的概念是在浏览器 1.0 中加入的  
强缓存：Expires，Cache-Control  
用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。  
协商缓存：Etag 和 If-None-Match、Last-Modified 和 If-Modified-Since  
用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。  
两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。  
两者区别：从名字就可以看出，强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互

### 导航流程是什么？从输入 URL 到页面展示这中间发生了什么

1. 输入地址 浏览器进程解析地址判断是域名还是文本搜索
2. 如果是域名则浏览器进程通过 ipc 传输给网络进程
3. 网络进程检查是否缓存数据，如果有则直接返回给浏览器进程
4. 如果不存在缓存则准备 tcp
5. 检查是否 dns 域名缓存 拿到 ip
6. 等待 tcp 队列因为每个域名最多 6 哥 tcp
7. 三次握手建立 tcp 链接
8. 构建请求行请求头请求体
9. 发送请求信息服务器接受请求返回响应头响应行
10. 网络进程解析响应头状态码如果是 301 302 则取请求头里的信息重定向 重新开始导航流程
11. 状态吗如果是 200 则就会检查响应的数据类型 如果是字节流类型就是下载调用浏览器下载 到此结束
12. 如果是文本类型则网络进程接受数据告知浏览器进程准备渲染进程
13. 一般里说一个 tab 只有渲染进程。但是特殊情况下如果两个 tab 不属于同一个 samesite 那么会重新创建一个渲染进程
14. 渲染进程准备完毕之后浏览器进程向渲染进程发送提交文档，建立传输管道
15. 渲染进程接受完信息之后发送确认提交
16. 浏览器接收到确认提交之后更新浏览器界面
17.

### html 是如何变成页面的

1. 渲染进程利用 html 解析器讲 html 解析成 dom 树
2. 渲染引擎解析 css 生成 stylesheets，计算 dom 的样式
3. 创建布局树 计算布局信息
4. 对布局树分层创建分层树
5. 为分层树创建绘制列表并且提交给合成线程，再线程池中完成
6. 合成线程将图层分成图块并且栅格化生成位图
7. 如果使用 gup 进程，则再 gpu 进程中完成称为光栅化
8. 合成线程完毕之后发送绘制图块命令给浏览器
9. 浏览器进程根据图块命令生成页面显示到显示器上

### 开启 gzip 需要与什么配合

需要客户端和服务端同时支持，如果客户端支持 gzip 的解析，那么只要服务端能够返回 gzip 的文件就可以启用 gzip 了  
客户端是否支持 gzip 呢，请求头中有个 Accept-Encoding 来标识对压缩的支持。客户端 http 请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到服务端的时候，服务器解析请求头，如果客户端支持 gzip 压缩，响应时对请求的资源进行压缩并返回给客户端，浏览器按照自己的方式解析，在 http 响应头，我们可以看到 content-encoding:gzip，这是指服务端使用了 gzip 的压缩方式

### 为什么同源策略？ 影响？ 解决方法？

试想一下，我们浏览器是完全开放的，可以互相随意访问，那么我们是不是可以去访问银行网站篡改信息获取登陆信息什么的，肯定是不安全的，因此引入了同源策略机制  
影响：dom：不同源之间 dom 是不可以互相操作的
数据层面：不同源之间的 cookie lacal 啥的是不能访问的
网络层面：不可以想不同源之间发起 xhr 和 fetch 请求
解决方案：想要便捷就要牺牲一点安全达到平衡  
可以插件 script 脚本  
跨域资源共享解决请求问题
跨文档消息机制

### 安全机制

1. 页面安全  
   xss 跨站脚本攻击 注入脚本获取 cookie 篡改信息
   分为存储型 反射型 dom 型
   防御：对输入输出的内容进行校验 转码编译  
    充分利用 csp 来控制
   开启 cookie 的只读模式  
   csrf 跨站请求伪造 页面利用目标网站的登录的 cookie 来请求 篡改数据
   防御：利用 cookie 的 samesite 三种模式的严格模式  
    验证相应头的请求来源  
    使用 token 模式 验证码
   x-loack 利用浏览器的缓存机制 去猜测用户信息

2. 操作系统安全
   安全沙盒 将浏览器的渲染内核和浏览器内核隔离开，因为在渲染内核内可以获取操作系统的一些权限，因此我们要加这么一层保护机制，获取数据 页面交互 网络请求 都是用 ipc 跟浏览器内核来交互
   iframe 的站点隔离 强隔离 内存 dom 之前都是强隔离 不能突破
3. 网络安全
   https = http+ssl  
   加密方法：对称+非对称+证书的方式  
   浏览器向服务器发送对称和非对称加密套件和随机数  
   服务器返回服务器发送对称和非对称加密套件和新随机数+数字证书  
   浏览器验证通过后利用数字证书里的公钥将两个随机数生成 premasetr 加密 发送给服务器并用私钥解密  
    这时候两端都有两个随机和 premaster 用来生成真正的 master 钥匙来交互  
   浏览器验证证书  
   浏览器读取证书中的明文，采用 ca 中的相同的 hash 函数去计算得出文件摘要和用 ca 的公钥解密出来的的信息摘要去对比验证 还可能验证 ca 的来源
