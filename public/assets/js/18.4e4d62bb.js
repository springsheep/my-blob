(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{581:function(a,t,r){"use strict";r.r(t);var v=r(5),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),r("h3",{attrs:{id:"调用栈中的数据是如何回收的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用栈中的数据是如何回收的"}},[a._v("#")]),a._v(" 调用栈中的数据是如何回收的")]),a._v(" "),r("p",[a._v("当一个函数调用结束的时候，js引擎会通过下移ESP（记录当前执行状态的指针）来销毁改函数保存在调用栈中的执行上下文")]),a._v(" "),r("h3",{attrs:{id:"堆中的数据是如何回收的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆中的数据是如何回收的"}},[a._v("#")]),a._v(" 堆中的数据是如何回收的")]),a._v(" "),r("p",[a._v("收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器")]),a._v(" "),r("p",[a._v("根据生命周期把堆分成新生代和旧生代两个区域")]),a._v(" "),r("ol",[r("li",[a._v("新生代：生存时间短 比较小")]),a._v(" "),r("li",[a._v("老生代： 生存时间长 文件大\n对于这两种不同的区域使用主垃圾回收器（老） 副垃圾回收器（新）")])]),a._v(" "),r("h3",{attrs:{id:"垃圾回收器的工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[a._v("#")]),a._v(" 垃圾回收器的工作流程")]),a._v(" "),r("ol",[r("li",[a._v("引数清理")]),a._v(" "),r("li",[a._v("标记清理 遍历所有的对象添加标记，然后对活跃的对象清楚标记 然后回收非活跃对象所占据的内存，最后整理内存")])]),a._v(" "),r("p",[a._v("一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器")]),a._v(" "),r("h3",{attrs:{id:"副垃圾回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[a._v("#")]),a._v(" 副垃圾回收器")]),a._v(" "),r("p",[a._v("副垃圾回收主要负责回收新生区的对象，使用用Scavenge 算法来处理，将新生区分为对象区域和空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小\n因此，整个对象区域很容易被装满，所以出现了晋升策略，经过两次垃圾回收都还存在的对象 就会晋升到老代区域")]),a._v(" "),r("h3",{attrs:{id:"主垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收"}},[a._v("#")]),a._v(" 主垃圾回收")]),a._v(" "),r("p",[a._v("主垃圾回收主要负责旧生代区域，除了一些从新生代晋升的对象还有一些比较大的对象会直接分配到旧生代\n因为旧生代的对象大，如果也采用Scavenge算法，那么耗时大因此在旧生代采用了标记清理")]),a._v(" "),r("p",[a._v("除此之外还要了解全停顿，因为在进行垃圾回收的时候js脚本是暂停下来的，试想如果垃圾太多那么我js等待时间就比较长，在新生代还好但是老生代的数据都比较大，所以为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法")]),a._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),r("ol",[r("li",[a._v("要知道什么是垃圾回收")]),a._v(" "),r("li",[a._v("栈和堆里的是怎么回收的")]),a._v(" "),r("li",[a._v("新旧生代区别")]),a._v(" "),r("li",[a._v("全暂停 处理的方法")])]),a._v(" "),r("h2",{attrs:{id:"宏观的浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#宏观的浏览器"}},[a._v("#")]),a._v(" 宏观的浏览器")]),a._v(" "),r("h3",{attrs:{id:"打开浏览器有哪些进程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#打开浏览器有哪些进程"}},[a._v("#")]),a._v(" 打开浏览器有哪些进程")]),a._v(" "),r("p",[a._v("敬请期待")]),a._v(" "),r("h3",{attrs:{id:"如何保证文件完整的传送到浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何保证文件完整的传送到浏览器"}},[a._v("#")]),a._v(" 如何保证文件完整的传送到浏览器")]),a._v(" "),r("p",[a._v("敬请期待")]),a._v(" "),r("h3",{attrs:{id:"为什么第二次打开网站变快了"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么第二次打开网站变快了"}},[a._v("#")]),a._v(" 为什么第二次打开网站变快了")]),a._v(" "),r("p",[a._v("敬请期待")]),a._v(" "),r("h3",{attrs:{id:"浏览器的缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的缓存"}},[a._v("#")]),a._v(" 浏览器的缓存")]),a._v(" "),r("p",[a._v("缓存的概念是在浏览器1.0中加入的"),r("br"),a._v("\n强缓存：Expires，Cache-Control"),r("br"),a._v("\n用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。"),r("br"),a._v("\n协商缓存：Etag和If-None-Match、Last-Modified和If-Modified-Since"),r("br"),a._v("\n用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。"),r("br"),a._v("\n两者共同点：客户端获取的数据最后都是熊客户端的缓存中取得。"),r("br"),a._v("\n两者区别：从名字就可以看出，强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互")]),a._v(" "),r("h3",{attrs:{id:"导航流程是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#导航流程是什么"}},[a._v("#")]),a._v(" 导航流程是什么？")]),a._v(" "),r("p",[a._v("敬请期待")]),a._v(" "),r("h3",{attrs:{id:"html是如何变成页面的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#html是如何变成页面的"}},[a._v("#")]),a._v(" html是如何变成页面的")]),a._v(" "),r("p",[a._v("敬请期待")]),a._v(" "),r("h3",{attrs:{id:"开启gzip-需要与什么配合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开启gzip-需要与什么配合"}},[a._v("#")]),a._v(" 开启gzip 需要与什么配合")]),a._v(" "),r("p",[a._v("需要客户端和服务端同时支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了"),r("br"),a._v("\n客户端是否支持gzip呢，请求头中有个Accept-Encoding来标识对压缩的支持。客户端http请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到服务端的时候，服务器解析请求头，如果客户端支持gzip压缩，响应时对请求的资源进行压缩并返回给客户端，浏览器按照自己的方式解析，在http响应头，我们可以看到content-encoding:gzip，这是指服务端使用了gzip的压缩方式")]),a._v(" "),r("h3",{attrs:{id:"为什么同源策略-影响-解决方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么同源策略-影响-解决方法"}},[a._v("#")]),a._v(" 为什么同源策略？ 影响？ 解决方法？")]),a._v(" "),r("p",[a._v("试想一下，我们浏览器是完全开放的，可以互相随意访问，那么我们是不是可以去访问银行网站篡改信息获取登陆信息什么的，肯定是不安全的，因此引入了同源策略机制"),r("br"),a._v("\n影响：dom：不同源之间dom是不可以互相操作的\n数据层面：不同源之间的cookie lacal啥的是不能访问的\n网络层面：不可以想不同源之间发起xhr和fetch请求\n解决方案：想要便捷就要牺牲一点安全达到平衡"),r("br"),a._v("\n可以插件script脚本"),r("br"),a._v("\n跨域资源共享解决请求问题\n跨文档消息机制")]),a._v(" "),r("h3",{attrs:{id:"安全机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安全机制"}},[a._v("#")]),a._v(" 安全机制")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("页面安全"),r("br"),a._v("\nxss 跨站脚本攻击 注入脚本获取cookie 篡改信息\n分为存储型 反射型  dom型\n防御：对输入输出的内容进行校验 转码编译"),r("br"),a._v("\n充分利用csp来控制\n开启cookie的只读模式"),r("br"),a._v("\ncsrf 跨站请求伪造 页面利用目标网站的登录的cookie来请求 篡改数据\n防御：利用cookie的samesite 三种模式的严格模式"),r("br"),a._v("\n验证相应头的请求来源"),r("br"),a._v("\n使用token模式 验证码\nx-loack 利用浏览器的缓存机制 去猜测用户信息")])]),a._v(" "),r("li",[r("p",[a._v("操作系统安全\n安全沙盒 将浏览器的渲染内核和浏览器内核隔离开，因为在渲染内核内可以获取操作系统的一些权限，因此我们要加这么一层保护机制，获取数据 页面交互 网络请求 都是用ipc跟浏览器内核来交互\niframe的站点隔离 强隔离 内存dom 之前都是强隔离 不能突破")])]),a._v(" "),r("li",[r("p",[a._v("网络安全\nhttps = http+ssl"),r("br"),a._v("\n加密方法：对称+非对称+证书的方式"),r("br"),a._v("\n浏览器向服务器发送对称和非对称加密套件和随机数"),r("br"),a._v("\n服务器返回服务器发送对称和非对称加密套件和新随机数+数字证书"),r("br"),a._v("\n浏览器验证通过后利用数字证书里的公钥将两个随机数生成premasetr加密 发送给服务器并用私钥解密"),r("br"),a._v("\n这时候两端都有两个随机和premaster用来生成真正的master钥匙来交互"),r("br"),a._v("\n浏览器验证证书"),r("br"),a._v("\n浏览器读取证书中的明文，采用ca中的相同的hash函数去计算得出文件摘要和用ca的公钥解密出来的的信息摘要去对比验证 还可能验证ca的来源")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);